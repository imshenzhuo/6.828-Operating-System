## 使用说明

1. 安装qemu
2. 制作镜像文件 `make` 生成`kernel`文件
3. 在一个终端运行`make qemu-nox-gdb`
4. 另一个终端运行`gdb` 即可调试
5. 结束时, 在第一个终端 `ctrl a + x`退出

## 帮助

- hw主页上帮助信息完全足够, 参照`bootblock.asm`文件
- 需要的知识参考 [stack](../../prepare/stack.md)



## 结果

当执行完代码

``` asm
=> 0x7db2:	call   *0x10018
```

当前执行指令的地址是就是`0x10000c` , 栈的内容是

``` asm
(gdb) x/24x $esp
0x7bbc:	0x00007db8	0x00100000	0x00009516	0x00001000
0x7bcc:	0x00000000	0x00000000	0x00000000	0x00000000
0x7bdc:	0x00010054	0x00000000	0x00000000	0x00000000
0x7bec:	0x00000000	0x00000000	0x00000000	0x00000000
0x7bfc:	0x00007c4d	0x8ec031fa	0x8ec08ed8	0xa864e4d0
0x7c0c:	0xb0fa7502	0xe464e6d1	0x7502a864	0xe6dfb0fa
```

实际上, 是在执行`bootmain`函数的时候, 没有按照正常流程返回函数, 而是栈不变, 直接跳到别处继续执行. 所以就留下了原来函数中的内容

从`0x7bbc`到`0x7c00`都是栈的区域, `0x7bbc`处的内容是执行`call`命令后下一条指令的地址, 其他的内容是函数中的局部变量以及手动压入栈的寄存器值(都是0)